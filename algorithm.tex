\documentclass{article}

\usepackage{geometry}
\usepackage{xeCJK}
\usepackage{minted}
\usepackage[colorlinks,linkcolor=blue]{hyperref}
\usepackage{amsmath}

% 设置页大小和页边距，或者scale=0.8
\geometry{a4paper,left=3.18cm,right=3.18cm,top=2.54cm,bottom=2.54cm}
% 声明分区：等宽字体，制表符号，等宽空格，ASCII
\xeCJKDeclareSubCJKBlock{MonoFont}{ "2500 -> "257F, "2002, "01 -> "F0 }
% 中文默认没有斜体和粗体格式，开启伪斜体和指定黑体；MonoFont分区指定字体为等宽字体Menlo
\setCJKmainfont[AutoFakeSlant, BoldFont=SimHei, MonoFont=Menlo]{SimSun}

\begin{document}
\section{基础}
  \subsection{最大公约数}
  辗转相除法：
  \begin{enumerate}
    \item p和q为两个非负整数，且不同时为0；
    \item q为0时，则p为最大公约数；
    \item p \% q 余数为r；如果r为0，则结果为q；
    \item 如果r不为0；则p = q；q = r；继续上一步骤（\textbf{与余数辗转相除}）
  \end{enumerate}

  \inputminted[linenos]{java}{src/chapter01/GCD.java}

  \subsection{抽象数据类型（ADT）}
  抽象数据类型（Abstract Data Type，ADT），对算法结构的抽象，简化描述抽象的算法。

  \subsection{二分查找}
  \begin{enumerate}
    \item 已经排序的元素列表；以及待查询的目标元素；查询时，每次减半；
    \item 列表中间元素大于目标元素，则继续查询\textbf{[low, mid - 1]}；
    \item 列表中间元素小于目标元素，则继续查询\textbf{[mid + 1, high]}；
    \item 直到中间元素与目标元素相等，返回mid；或者low > high，返回-1。
  \end{enumerate}

  \inputminted[linenos]{java}{src/chapter01/BinarySearch.java}

  \subsection{算术表达式运算}
  目前支持+、-、*、/运算符，参考：\href{http://faculty.cs.niu.edu/~hutchins/csci241/eval.htm}{算法描述} 。
  \begin{enumerate}
    \item 数值入栈，左括号入栈；
    \item 操作符号，如果操作符栈不为空，操作符栈顶符号不为左括号，且栈顶符号优先级 $\geq$ 当前扫描的符号，循环计算双栈；每次将结果压入操作数栈；最后压入当前操作符到栈中；
    \item 右括号，循环计算双栈，直到操作符栈为空，或达到左符号；每次计算的结果重新压入操作数栈；
    \item 最后操作符栈不为空，继续循环计算。
  \end{enumerate}

  \inputminted[linenos, fontsize=\small]{java}{src/chapter01/ArithmeticExpression.java}

  \subsection{定容栈}
  固定大小的栈；如果需要扩容，提供resize方法，在push方法中检测是否需要扩容，然后调用resize方法；可以创建更大的数组，然后复制到新的数组中。

  \inputminted[linenos]{java}{src/chapter01/FixedCapacityStack.java}

  \subsection{栈的链表实现}
  链表实现的栈没有限制容量。

  \inputminted[linenos]{java}{src/chapter01/LinkedStack.java}

  \subsection{队列的链表实现}

  \inputminted[linenos]{java}{src/chapter01/LinkedQueue.java}

  \subsection{背包}
  背包和栈类似，把push替换成add，然后移除pop；背包只添加元素，以及遍历元素。栈和队列也可以实现Iterator接口。

  \inputminted[linenos]{java}{src/chapter01/Bag.java}

  \subsection{算法分析}
  \subsubsection{增长数量级分类}

  \begin{enumerate}
    \item 常数级别：$1$
    \item 对数级别：$\log N$
    \item 线性级别：$N$
    \item 线性对数级别：$N * \log N$
    \item 平方级别：$N^2$
    \item 对数级别：$N^3$
    \item 指数级别：$2^N$
  \end{enumerate}

  \subsubsection{2-sum}
  \inputminted[linenos]{java}{src/chapter01/TwoSum.java}

  \subsubsection{3-sum}
  \inputminted[linenos]{java}{src/chapter01/ThreeSum.java}

  \subsubsection{下界}
  在2-sum和3-sum例子中，是否能找到更优的算法，为算法在最坏的情况下的运行时间给出一个下界。

  \subsubsection{倍率实验}
  每次增加一倍输入规模，然后计算问题解决所需的时间，以此来预测任意问题的运行时间的增长数量级。

\end{document}
